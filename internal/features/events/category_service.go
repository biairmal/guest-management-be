package events

import (
	"context"
	"errors"
	"time"

	"github.com/biairmal/go-sdk/errorz"
	"github.com/biairmal/go-sdk/logger"
	"github.com/biairmal/go-sdk/repository"
	"github.com/google/uuid"
)

type CategoryServiceOptions struct{}

// CategoryService provides application logic for event categories.
type CategoryService struct {
	repo    CategoryRepository
	logger  logger.Logger
	options CategoryServiceOptions
}

// NewCategoryService returns a CategoryService with the given dependencies.
func NewCategoryService(
	options CategoryServiceOptions,
	logger logger.Logger,
	repo CategoryRepository,
) *CategoryService {
	return &CategoryService{options: options, logger: logger, repo: repo}
}

// CreateInput is the input for creating an event category.
type CreateInput struct {
	Source   string     `json:"source"` // "app" or "tenant"
	TenantID *uuid.UUID `json:"tenant_id,omitempty"`
	Name     string     `json:"name"`
}

// UpdateInput is the input for updating an event category.
type UpdateInput struct {
	Source   *string    `json:"source,omitempty"`
	TenantID *uuid.UUID `json:"tenant_id,omitempty"`
	Name     *string    `json:"name,omitempty"`
}

// Create creates a new event category. ID is generated by the service.
func (s *CategoryService) Create(ctx context.Context, in CreateInput) (*EventCategory, error) {
	if in.Name == "" {
		return nil, errorz.BadRequest().WithMessage("name is required")
	}
	if in.Source != SourceApp && in.Source != SourceTenant {
		return nil, errorz.BadRequest().WithMessage("source must be 'app' or 'tenant'")
	}
	if in.Source == SourceApp && in.TenantID != nil {
		return nil, errorz.BadRequest().WithMessage("tenant_id must be null when source is 'app'")
	}
	if in.Source == SourceTenant && in.TenantID == nil {
		return nil, errorz.BadRequest().WithMessage("tenant_id is required when source is 'tenant'")
	}

	now := time.Now()
	entity := &EventCategory{
		ID:        uuid.New(),
		Source:    in.Source,
		TenantID:  in.TenantID,
		Name:      in.Name,
		CreatedAt: now,
		UpdatedAt: now,
	}

	if err := s.repo.Create(ctx, entity); err != nil {
		if errors.Is(err, repository.ErrAlreadyExists) {
			return nil, errorz.Conflict().WithMessage("event category already exists")
		}
		if errors.Is(err, repository.ErrInvalidEntity) {
			return nil, errorz.UnprocessableEntity().WithMessage("invalid event category data")
		}
		s.logger.ErrorWithContext(ctx, "event category create failed", logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to create event category")
	}

	s.logger.InfoWithContext(ctx, "event category created", logger.F("id", entity.ID))
	return entity, nil
}

// GetByID returns an event category by ID, or errorz.NotFound if not found or soft-deleted.
func (s *CategoryService) GetByID(ctx context.Context, id uuid.UUID) (*EventCategory, error) {
	entity, err := s.repo.GetByID(ctx, id.String())
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category get failed", logger.F("id", id), logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to get event category")
	}
	return entity, nil
}

// Update updates an event category. Only non-nil fields in in are applied.
func (s *CategoryService) Update(ctx context.Context, id uuid.UUID, in UpdateInput) (*EventCategory, error) {
	entity, err := s.repo.GetByID(ctx, id.String())
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category get for update failed", logger.F("id", id), logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to get event category")
	}

	if in.Source != nil {
		if *in.Source != SourceApp && *in.Source != SourceTenant {
			return nil, errorz.BadRequest().WithMessage("source must be 'app' or 'tenant'")
		}
		entity.Source = *in.Source
	}
	if in.TenantID != nil {
		entity.TenantID = in.TenantID
	}
	if in.Name != nil {
		if *in.Name == "" {
			return nil, errorz.BadRequest().WithMessage("name cannot be empty")
		}
		entity.Name = *in.Name
	}
	entity.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, id.String(), entity); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category update failed", logger.F("id", id), logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to update event category")
	}

	s.logger.InfoWithContext(ctx, "event category updated", logger.F("id", id))
	return entity, nil
}

// Delete soft-deletes an event category.
func (s *CategoryService) Delete(ctx context.Context, id uuid.UUID) error {
	if err := s.repo.Delete(ctx, id.String()); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category delete failed", logger.F("id", id), logger.F("error", err))
		return errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to delete event category")
	}
	s.logger.InfoWithContext(ctx, "event category deleted", logger.F("id", id))
	return nil
}

// ListResult holds paginated list and metadata.
type ListResult struct {
	Items      []*EventCategory `json:"items"`
	Total      int64            `json:"total"`
	Limit      int              `json:"limit"`
	Offset     int              `json:"offset"`
	TotalPages int              `json:"total_pages"`
}

// List returns event categories with optional filter, sort, and pagination.
func (s *CategoryService) List(
	ctx context.Context,
	filter repository.Filter,
	sort repository.Sort,
	limit, offset int,
) (*ListResult, error) {
	opts := &repository.ListOptions{
		Filter: filter,
		Sort:   sort,
		Pagination: repository.Pagination{
			Limit:  limit,
			Offset: offset,
		},
	}
	items, err := s.repo.List(ctx, opts)
	if err != nil {
		s.logger.ErrorWithContext(ctx, "event category list failed", logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to list event categories")
	}
	total, err := s.repo.Count(ctx, filter)
	if err != nil {
		s.logger.ErrorWithContext(ctx, "event category count failed", logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to count event categories")
	}

	totalPages := 1
	if limit > 0 {
		totalPages = int(total) / limit
		if int(total)%limit > 0 {
			totalPages++
		}
	}
	return &ListResult{
		Items:      items,
		Total:      total,
		Limit:      limit,
		Offset:     offset,
		TotalPages: totalPages,
	}, nil
}
