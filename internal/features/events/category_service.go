package events

import (
	"context"
	"errors"

	common "github.com/biairmal/go-sdk/common/dto"
	"github.com/biairmal/go-sdk/errorz"
	"github.com/biairmal/go-sdk/logger"
	"github.com/biairmal/go-sdk/repository"
	"github.com/google/uuid"
)

// CategoryService defines the application-level operations for event categories.
type CategoryService interface {
	Create(ctx context.Context, in CreateInput) (*EventCategory, error)
	GetByID(ctx context.Context, id uuid.UUID) (*EventCategory, error)
	Update(ctx context.Context, id uuid.UUID, in UpdateInput) (*EventCategory, error)
	Delete(ctx context.Context, id uuid.UUID) error
	List(ctx context.Context, params *EventCategoryListParams) (*common.PageResponse[EventCategory], error)
}

// CategoryServiceOptions holds configuration for the category service.
type CategoryServiceOptions struct{}

// categoryServiceImpl is the concrete implementation of CategoryService.
type categoryServiceImpl struct {
	repo    CategoryRepository
	logger  logger.Logger
	options CategoryServiceOptions
}

// NewCategoryService returns a CategoryService with the given dependencies.
func NewCategoryService(
	options CategoryServiceOptions,
	logger logger.Logger,
	repo CategoryRepository,
) CategoryService {
	return &categoryServiceImpl{options: options, logger: logger, repo: repo}
}

// CreateInput is the input for creating an event category.
//
// swagger:model CreateInput
type CreateInput struct {
	Source   string     `json:"source"` // "app" or "tenant"
	TenantID *uuid.UUID `json:"tenant_id,omitempty"`
	Name     string     `json:"name"`
}

// UpdateInput is the input for updating an event category.
//
// swagger:model UpdateInput
type UpdateInput struct {
	Source   *string    `json:"source,omitempty"`
	TenantID *uuid.UUID `json:"tenant_id,omitempty"`
	Name     *string    `json:"name,omitempty"`
}

// Create creates a new event category. ID is generated by the service.
// Audit fields (created_at, updated_at) are set by the AuditableRepository.
func (s *categoryServiceImpl) Create(ctx context.Context, in CreateInput) (*EventCategory, error) {
	if in.Name == "" {
		return nil, errorz.BadRequest().WithMessage("name is required")
	}
	if in.Source != SourceApp && in.Source != SourceTenant {
		return nil, errorz.BadRequest().WithMessage("source must be 'app' or 'tenant'")
	}
	if in.Source == SourceApp && in.TenantID != nil {
		return nil, errorz.BadRequest().WithMessage("tenant_id must be null when source is 'app'")
	}
	if in.Source == SourceTenant && in.TenantID == nil {
		return nil, errorz.BadRequest().WithMessage("tenant_id is required when source is 'tenant'")
	}

	entity := &EventCategory{
		ID:       uuid.New(),
		Source:   in.Source,
		TenantID: in.TenantID,
		Name:     in.Name,
	}

	if err := s.repo.Create(ctx, entity); err != nil {
		if errors.Is(err, repository.ErrAlreadyExists) {
			return nil, errorz.Conflict().WithMessage("event category already exists")
		}
		if errors.Is(err, repository.ErrInvalidEntity) {
			return nil, errorz.UnprocessableEntity().WithMessage("invalid event category data")
		}
		s.logger.ErrorWithContext(ctx, "event category create failed", logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to create event category")
	}

	s.logger.InfoWithContext(ctx, "event category created", logger.F("id", entity.ID))
	return entity, nil
}

// GetByID returns an event category by ID, or errorz.NotFound if not found or soft-deleted.
func (s *categoryServiceImpl) GetByID(ctx context.Context, id uuid.UUID) (*EventCategory, error) {
	entity, err := s.repo.GetByID(ctx, id.String())
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category get failed", logger.F("id", id), logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to get event category")
	}
	return entity, nil
}

// Update updates an event category. Only non-nil fields in UpdateInput are applied.
// The updated_at field is set by the AuditableRepository.
func (s *categoryServiceImpl) Update(ctx context.Context, id uuid.UUID, in UpdateInput) (*EventCategory, error) {
	entity, err := s.repo.GetByID(ctx, id.String())
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category get for update failed", logger.F("id", id), logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to get event category")
	}

	if in.Source != nil {
		if *in.Source != SourceApp && *in.Source != SourceTenant {
			return nil, errorz.BadRequest().WithMessage("source must be 'app' or 'tenant'")
		}
		entity.Source = *in.Source
	}
	if in.TenantID != nil {
		entity.TenantID = in.TenantID
	}
	if in.Name != nil {
		if *in.Name == "" {
			return nil, errorz.BadRequest().WithMessage("name cannot be empty")
		}
		entity.Name = *in.Name
	}

	if err := s.repo.Update(ctx, id.String(), entity); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category update failed", logger.F("id", id), logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to update event category")
	}

	s.logger.InfoWithContext(ctx, "event category updated", logger.F("id", id))
	return entity, nil
}

// Delete soft-deletes an event category. The AuditableRepository handles
// setting deleted_at and updated_at.
func (s *categoryServiceImpl) Delete(ctx context.Context, id uuid.UUID) error {
	if err := s.repo.Delete(ctx, id.String()); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return errorz.NotFound().WithMessage("event category not found")
		}
		s.logger.ErrorWithContext(ctx, "event category delete failed", logger.F("id", id), logger.F("error", err))
		return errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to delete event category")
	}
	s.logger.InfoWithContext(ctx, "event category deleted", logger.F("id", id))
	return nil
}

// List returns event categories with filter, sort, and pagination from EventCategoryListParams.
func (s *categoryServiceImpl) List(ctx context.Context, params *EventCategoryListParams) (*common.PageResponse[EventCategory], error) {
	opts := listParamsToListOptions(params)
	items, total, err := s.repo.List(ctx, opts)
	if err != nil {
		s.logger.ErrorWithContext(ctx, "event category list failed", logger.F("error", err))
		return nil, errorz.Wrap(err).WithCode(errorz.CodeInternal).WithMessage("failed to list event categories")
	}
	return common.NewPageResponse(items, total, params.Page, params.Size), nil
}

// listParamsToListOptions converts EventCategoryListParams to repository.ListOptions.
func listParamsToListOptions(params *EventCategoryListParams) *repository.ListOptions {
	if params == nil {
		return &repository.ListOptions{}
	}

	page, size := params.Page, params.Size
	if page < 1 {
		page = 1
	}
	if size < 1 {
		size = 20
	}
	if size > 100 {
		size = 100
	}
	offset := (page - 1) * size

	// Convert simple equality filters to repository filter conditions.
	var conditions []repository.FilterCondition
	for field, value := range params.Filters {
		conditions = append(conditions, repository.FilterCondition{
			Field:    field,
			Operator: repository.FilterOperatorEq,
			Value:    value,
		})
	}

	// Convert common.SortSpec to repository.Sort.
	var sorts []repository.Sort
	for _, s := range params.Sorts {
		dir := repository.SortAsc
		if s.Direction == common.SortDesc {
			dir = repository.SortDesc
		}
		sorts = append(sorts, repository.Sort{Field: s.Field, Direction: dir})
	}

	return &repository.ListOptions{
		Filter:     repository.Filter{Conditions: conditions},
		Pagination: repository.Pagination{Limit: size, Offset: offset},
		Sorts:      sorts,
	}
}
